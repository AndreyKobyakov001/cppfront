 // token t; //initialize
    // t.string = 'xx';
    // fuzzing::token token_to_proto = fuzzing::TokenToProto(token);
    // EXPECT_THAT(token_proto, EqualsProto(string:"xx"));
    
// Visitor interface
// class Visitor {
// public:
//     virtual void visitTranslationUnit(const translation_unit_node& node) = 0;
// };

// class translation_unit_node {
// public:
//     // ...

//     virtual void accept(Visitor& visitor) {
//         visitor.visitTranslationUnit(*this);
//     }

//     // ...
// };

// // Concrete visitor class for printing the translation unit
// class PrintVisitor : public Visitor {
// public:
//     void visitTranslationUnit(const translation_unit_node& node) override {
//         std::cout << "Translation Unit" << std::endl;
//         // Perform any additional printing or processing specific to the translation unit
//     }
// };

// auto start(translation_unit_node const& node, int indent) -> void {
//     PrintVisitor visitor;
//     node.accept(visitor);
// }


class Visitor {
public:
    virtual void visit(token const&) = 0;
    virtual void visit(literal_node const&) = 0;
    // Define visit functions for other node types...
};

class token {
public:
    // ...
    virtual void accept(Visitor& visitor) const {
        visitor.visit(*this);
    }
};

class literal_node {
public:
    // ...
    virtual void accept(Visitor& visitor) const {
        visitor.visit(*this);
    }
};

// Implement accept functions for other node types...

class ParseTreePrinter : public Visitor {
public:
    void visit(token const& n) override {
        // Handle token visitation
        // Print information about the token
    }

    void visit(literal_node const& n) override {
        // Handle literal_node visitation
        // Print information about the literal_node
    }

    // Implement visit functions for other node types...
};

// Create the ParseTreePrinter visitor
ParseTreePrinter printer;

// Traverse the parse tree and perform visitation
translation_unit_node root;  // Assuming this is your root node
root.accept(printer);


#ifndef __CPP2_FUZZING_AST_TO_PROTO
#define __CPP2_FUZZING_AST_TO_PROTO

#include <stdio.h>
#include "source/cppfront.h"
#include "/source/parse.h"
#include <iostream>
#include <string>
#include <variant>
#include <memory>

namespace cpp2::fuzzing {

// Builds a protobuf representation of `ast`.
auto AstToProto(const translation_unit_node& parse_tree) -> fuzzing::translation_unit_node;
    //Do something :)
}  // namespace cpp2::fuzzing


//Chad G. Pete

enum class passing_style {
    in,
    copy,
    inout,
    out,
    move,
    forward
};

class token {
public:
    std::string to_string() const {
        return "token";
    }
};

class literal_node {
};

class expression_node {
};

class expression_list_node {
public:
    struct term {
        passing_style pass;
    };
};

class primary_expression_node {
};

class prefix_expression_node {
};

class is_as_expression_node {
};

template <typename Name, typename Term>
class binary_expression_node {
};

class expression_statement_node {
};

class postfix_expression_node {
};

class unqualified_id_node {
};

class qualified_id_node {
};

class type_id_node {
};

class id_expression_node {
};

class statement_node {
};

class compound_statement_node {
};

class selection_statement_node {
public:
    bool is_constexpr;
};

class alternative_node {
};

class jump_statement_node {
};

class inspect_expression_node {
public:
    bool is_constexpr;
};

class return_statement_node {
};

class iteration_statement_node {
public:
    std::string_view identifier;
};

class contract_node {
public:
    std::string_view kind;
    std::string_view message;
};

class type_node {
};

class namespace_node {
};

class function_type_node {
public:
    std::string throws;
    using returns_t = std::variant<function_returns_tag, id_expression_node>;
    returns_t returns;
};

class function_returns_tag {
};

class template_args_tag {
};

class declaration_node {
public:
    enum class variant {
        a_function,
        an_object,
        a_type,
        a_namespace,
        an_alias
    } type;

    int access;
    std::string captures;
};

class parameter_declaration_node {
public:
    passing_style pass;
    enum class modifier {
        implicit,
        virtual_,
        override_,
        final
    } mod;

    std::unique_ptr<declaration_node> declaration;
};

class parameter_declaration_list_node {
};

class translation_unit_node {
public:
    void accept(class Visitor& visitor) const;
};

class Visitor {
public:
    virtual void visit(token const&) = 0;
    virtual void visit(literal_node const&) = 0;
    virtual void visit(expression_node const&) = 0;
    virtual void visit(expression_list_node::term const&, int indent) = 0;
    virtual void visit(expression_list_node const&, int indent) = 0;
    virtual void visit(primary_expression_node const&, int indent) = 0;
    virtual void visit(prefix_expression_node const&, int indent) = 0;
    virtual void visit(is_as_expression_node const&, int indent) = 0;
    virtual void visit(binary_expression_node<Name, Term> const&, int indent) = 0;
    virtual void visit(expression_statement_node const&, int indent) = 0;
    virtual void visit(postfix_expression_node const&, int indent) = 0;
    virtual void visit(unqualified_id_node const&, int indent) = 0;
    virtual void visit(qualified_id_node const&, int indent) = 0;
    virtual void visit(type_id_node const&, int indent) = 0;
    virtual void visit(id_expression_node const&, int indent) = 0;
    virtual void visit(statement_node const&, int indent) = 0;
    virtual void visit(compound_statement_node const&, int indent) = 0;
    virtual void visit(selection_statement_node const& n, int indent) = 0;
    virtual void visit(alternative_node const&, int indent) = 0;
    virtual void visit(jump_statement_node const&, int indent) = 0;
    virtual void visit(inspect_expression_node const& n, int indent) = 0;
    virtual void visit(return_statement_node const&, int indent) = 0;
    virtual void visit(iteration_statement_node const& n, int indent) = 0;
    virtual void visit(contract_node const& n, int indent) = 0;
    virtual void visit(type_node const&, int indent) = 0;
    virtual void visit(namespace_node const&, int indent) = 0;
    virtual void visit(function_type_node const& n, int indent) = 0;
    virtual void visit(function_returns_tag const&, int indent) = 0;
    virtual void visit(template_args_tag const&, int indent) = 0;
    virtual void visit(declaration_node const& n, int indent) = 0;
    virtual void visit(parameter_declaration_node const& n, int indent) = 0;
    virtual void visit(parameter_declaration_list_node const&, int indent) = 0;
    virtual void visit(translation_unit_node const&, int indent) = 0;
};

void translation_unit_node::accept(Visitor& visitor) const {
    visitor.visit(*this);

    // Invoke accept for other child nodes
}

class ParseTreePrinter : public Visitor {
private:
    std::ostream& o;
    int indent_level;

public:
    ParseTreePrinter(std::ostream& output)
        : o(output), indent_level(0) {
    }

    std::string pre(int indent) {
        return std::string(indent, '\t');
    }

    void visit(token const& n) override {
        o << pre(indent_level) << n.to_string() << "\n";
    }

    void visit(literal_node const&) override {
        o << pre(indent_level) << "literal" << "\n";
    }

    void visit(expression_node const&, int indent) override {
        o << pre(indent_level) << "expression\n";
    }

    void visit(expression_list_node::term const&, int indent) override {
        o << pre(indent_level) << "expression-list term\n";
        if (n.pass == passing_style::out) {
            o << pre(indent_level + 1) << "out\n";
        }
    }

    void visit(expression_list_node const&, int indent) override {
        o << pre(indent_level) << "expression-list\n";
    }

    void visit(primary_expression_node const&, int indent) override {
        o << pre(indent_level) << "primary-expression\n";
    }

    void visit(prefix_expression_node const&, int indent) override {
        o << pre(indent_level) << "prefix-expression\n";
    }

    void visit(is_as_expression_node const&, int indent) override {
        o << pre(indent_level) << "is-as-expression\n";
    }

    template <class Name, typename Term>
    void visit(binary_expression_node<Name, Term> const&, int indent) override {
        o << pre(indent_level) << Name.value << "-expression\n";
    }

    void visit(expression_statement_node const&, int indent) override {
        o << pre(indent_level) << "expression-statement\n";
    }

    void visit(postfix_expression_node const&, int indent) override {
        o << pre(indent_level) << "postfix-expression\n";
    }

    void visit(unqualified_id_node const&, int indent) override {
        o << pre(indent_level) << "unqualified-id\n";
    }

    void visit(qualified_id_node const&, int indent) override {
        o << pre(indent_level) << "qualified-id\n";
    }

    void visit(type_id_node const&, int indent) override {
        o << pre(indent_level) << "type-id\n";
    }

    void visit(id_expression_node const&, int indent) override {
        o << pre(indent_level) << "id-expression\n";
    }

    void visit(statement_node const&, int indent) override {
        o << pre(indent_level) << "statement\n";
    }

    void visit(compound_statement_node const&, int indent) override {
        o << pre(indent_level) << "compound-statement\n";
    }

    void visit(selection_statement_node const& n, int indent) override {
        o << pre(indent_level) << "selection-statement\n";
        if (n.is_constexpr) {
            o << pre(indent_level + 1) << "constexpr\n";
        }
    }

    void visit(alternative_node const&, int indent) override {
        o << pre(indent_level) << "alternative\n";
    }

    void visit(jump_statement_node const& n, int indent) override {
        o << pre(indent_level) << "jump-statement\n";
    }

    void visit(inspect_expression_node const& n, int indent) override {
        o << pre(indent_level) << "inspect-expression\n";
        if (n.is_constexpr) {
            o << pre(indent_level + 1) << "constexpr\n";
        }
    }

    void visit(return_statement_node const&, int indent) override {
        o << pre(indent_level) << "return-statement\n";
    }

    void visit(iteration_statement_node const& n, int indent) override {
        o << pre(indent_level) << "iteration-statement\n";
        o << pre(indent_level + 1) << "identifier: " << n.identifier << "\n";
    }

    void visit(contract_node const& n, int indent) override {
        o << pre(indent_level) << "contract\n";
        o << pre(indent_level + 1) << "kind: " << n.kind << "\n";
        o << pre(indent_level + 1) << "message: " << n.message << "\n";
    }

    void visit(type_node const&, int indent) override {
        o << pre(indent_level) << "type\n";
    }

    void visit(namespace_node const&, int indent) override {
        o << pre(indent_level) << "namespace\n";
    }

    void visit(function_type_node const& n, int indent) override {
        o << pre(indent_level) << "function-type\n";
        o << pre(indent_level + 1) << "throws: " << n.throws << "\n";
        if (std::holds_alternative<id_expression_node>(n.returns)) {
            o << pre(indent_level + 1) << "returns: id-expression\n";
        } else {
            o << pre(indent_level + 1) << "returns: function_returns_tag\n";
        }
    }

    void visit(function_returns_tag const&, int indent) override {
        o << pre(indent_level) << "function-returns-tag\n";
    }

    void visit(template_args_tag const&, int indent) override {
        o << pre(indent_level) << "template-args-tag\n";
    }

    void visit(declaration_node const& n, int indent) override {
        o << pre(indent_level) << "declaration\n";
        switch (n.type) {
            case declaration_node::variant::a_function:
                o << pre(indent_level + 1) << "type: a_function\n";
                break;
            case declaration_node::variant::an_object:
                o << pre(indent_level + 1) << "type: an_object\n";
                break;
            case declaration_node::variant::a_type:
                o << pre(indent_level + 1) << "type: a_type\n";
                break;
            case declaration_node::variant::a_namespace:
                o << pre(indent_level + 1) << "type: a_namespace\n";
                break;
            case declaration_node::variant::an_alias:
                o << pre(indent_level + 1) << "type: an_alias\n";
                break;
        }
        o << pre(indent_level + 1) << "access: " << n.access << "\n";
        o << pre(indent_level + 1) << "captures: " << n.captures << "\n";
    }

    void visit(parameter_declaration_node const& n, int indent) override {
        o << pre(indent_level) << "parameter-declaration\n";
        o << pre(indent_level + 1) << "pass: ";
        switch (n.pass) {
            case passing_style::in:
                o << "in\n";
                break;
            case passing_style::copy:
                o << "copy\n";
                break;
            case passing_style::inout:
                o << "inout\n";
                break;
            case passing_style::out:
                o << "out\n";
                break;
            case passing_style::move:
                o << "move\n";
                break;
            case passing_style::forward:
                o << "forward\n";
                break;
        }
        o << pre(indent_level + 1) << "mod: ";
        switch (n.mod) {
            case parameter_declaration_node::modifier::implicit:
                o << "implicit\n";
                break;
            case parameter_declaration_node::modifier::virtual_:
                o << "virtual\n";
                break;
            case parameter_declaration_node::modifier::override_:
                o << "override\n";
                break;
            case parameter_declaration_node::modifier::final:
                o << "final\n";
                break;
        }
    }

    void visit(parameter_declaration_list_node const&, int indent) override {
        o << pre(indent_level) << "parameter-declaration-list\n";
    }

    void visit(translation_unit_node const&, int indent) override {
        o << pre(indent_level) << "translation-unit\n";
    }
};

int main() {
    translation_unit_node tree;

    ParseTreePrinter printer(std::cout);
    tree.accept(printer);

    return 0;
}


#endif  // __CPP2_FUZZING_AST_TO_PROTO



TEST(AstToProtoTest, SameProtoAfterClone) {
  int parsed_ok_count = 0;
  for (const llvm::StringRef f : *carbon_files) {
    Arena arena;
    const ErrorOr<AST> ast = Parse(&arena, f, /*parser_debug=*/false);
    if (ast.ok()) {
      ++parsed_ok_count;
      const AST clone = CloneAST(arena, *ast);
      const Fuzzing::Carbon orig_proto = AstToProto(*ast);
      const Fuzzing::Carbon clone_proto = AstToProto(clone);
      // TODO: Use EqualsProto once it's available.
      EXPECT_TRUE(google::protobuf::util::MessageDifferencer::Equals(
          orig_proto, clone_proto))
          << "clone produced a different AST. original:\n"
          << AstToString(*ast) << "clone:\n"
          << AstToString(clone);
    }
  }
  // Makes sure files were actually processed.
  EXPECT_GT(parsed_ok_count, 0);
}


auto PrimaryExpressionToProto(const primary_expression_node& primary_expression) -> fuzzing::primary_expression_node { 
    fuzzing::primary_expression_node primary_expression_proto;
    const auto& e = primary_expression.expr;
    if (std::holds_alternative<std::monostate>(e)) { 
    } else if (std::holds_alternative<const token*>(e)) { 
        *primary_expression_proto.mutable_identifier() = TokenToProto(*std::get<const token*>(e));
    } else if (std::holds_alternative<const expression_list_node*>(e)) { 
        *primary_expression_proto.mutable_expression_list() = TokenToProto(*std::get<const expression_list_node*>(e));
    } else if (std::holds_alternative<const id_expression_node*>(e)) { 
        *primary_expression_proto.mutable_id_expression() = TokenToProto(*std::get<const id_expression_node*>(e));
    } else if (std::holds_alternative<const declaration_node*>(e)) { 
        *primary_expression_proto.mutable_declaration() = TokenToProto(*std::get<const declaration_node*>(e));
    } else if (std::holds_alternative<const inspect_expression_node*>(e)) { 
        *primary_expression_proto.mutable_inspect() = TokenToProto(*std::get<const inspect_expression_node*>(e));
    } else if (std::holds_alternative<const literal_node*>(e)) { 
        *primary_expression_proto.mutable_literal() = TokenToProto(*std::get<const literal_node*>(e));
    }
    return primary_expression_proto;
}

#include "source/fuzzing/ast_to_proto.h"
#include "source/fuzzing/proto_to_cpp2.h"
#include "source/fuzzing/cpp2.pb.h" 

#include <gmock/gmock.h> //Doesn't bring in gMock 😎
#include <google/protobuf/descriptor.h>
#include <google/protobuf/util/message_differencer.h>
#include <gtest/gtest.h>

#include <filesystem>
#include <numeric>
#include <set>
#include <variant>
#include <ostream>
#include <sstream>

// #include "parse.h"
#include "source/cppfront.h"

namespace cpp2 {
namespace {
    
static std::vector<std::string_view>* cpp2_files = nullptr;

//use Throw for errors. 

auto translation_unit_to_string(cppfront& c) { 
    std::stringstream out;
    c.parser_debug_print(out);
    return out.str(); 
}

auto write_to_file(const std::string_view filename, const std::string_view contents) { 
  std::ofstream f;
  f.open(filename.data());
  f << contents; 
  f.close(); 
}

TEST(RoundTripTest, Roundtrip) {
  int parsed_ok_count = 0;
  int correct_count = 0; 
  // bool debug = false; 
  bool debug = true;
  // std::cout << "Hello world\n" << std::flush;
  std::cout << "Size:" << cpp2_files->size() << "\n" << std::flush;
  for (const std::string_view filename : *cpp2_files) {
    // std::cout << "Filename: " << filename << "\n" << std::flush;
    std::string f(filename);
    cppfront c(f); 
    if (!c.had_no_errors()) {
      c.print_errors();
      ADD_FAILURE() << "Parse error ";
    } else {
      parsed_ok_count++; //move ++ to the start for efficiency and all that (much good it'll do you)
      const std::unique_ptr<translation_unit_node>& parse_tree = c.get_parse_tree(); 
      if (1 == 0) {
        std::cout << "Parse tree time:" << parse_tree.get() << "\n" << std::flush;
      }
      const fuzzing::translation_unit_node translation_unit_proto = 
          TranslationUnitToProto(*parse_tree); //TODO: check if not null


      //DEBUGGING PURPOSES
      // if (debug) { 
      //   std::cout << "Generated proto from CPP2: \n" << translation_unit_proto.DebugString() << "\n" <<  std::flush;      
      // }
      // std::cout << "Translation Unit:\n" << translation_unit_to_string(c) << "\n"; 
     
     
      std::stringstream out;
      TranslationUnitToCpp2(translation_unit_proto, out); 
      write_to_file("/tmp/c2.cpp2", out.str());
      // if (debug) { 
      //   std::cout << "Generate CPP2 from proto \n" << std::flush;
      // }

      if(debug) { 
        SCOPED_TRACE(testing::Message()
                    << "Cpp2 file: " << filename << ", source from proto:\n"
                    << out.str());
      }
      //rename the out variable :)-|<
      
      std::istringstream source_from_proto(out.str());
      
      cppfront c2(f, source_from_proto); 
      if(debug) { 
        // std::cout << "Errors: \n";
        c2.print_errors();
      }
      const auto c_contents = translation_unit_to_string(c);
      const auto c2_contents = translation_unit_to_string(c2);
      write_to_file("/tmp/c_contents", c_contents);
      write_to_file("/tmp/c2_contents", c2_contents);
      write_to_file("/tmp/proto_tree", translation_unit_proto.DebugString());
      //rename this to not be retarded
      if (c2.had_no_errors()) {
        
        if (debug) {  
          EXPECT_EQ(c_contents, c2_contents);
        }
        
        
        const bool same = c_contents == c2_contents;
        if(same) { 
          correct_count++; 
        } else { 
          std::cout << parsed_ok_count << ". " << filename << " Different\n";
        }
        EXPECT_TRUE(same); 
      } else {
          if (debug) { 
            c2.print_errors();
          }
          std::cout << parsed_ok_count << ". " << filename << " HAS ERRORS" << "\n";
          ADD_FAILURE() << "Parse error ";
      }

      // if (c2.had_no_errors()) {
      //   ASSERT_EQ(translation_unit_to_string(c), translation_unit_to_string(c2));
      //   } 
      // //   else {
      // //     c2.print_errors();
      // //     ADD_FAILURE() << "Parse error ";
      // // }
    }
  }
  std::cout << "Correct File Parsing: " << correct_count << " out of " << parsed_ok_count << " :) \n"; 
  // Makes sure files were actually processed.
  EXPECT_GT(parsed_ok_count, 0);
}


} //namespace
} //namespace cpp2

auto main(int argc, char** argv) -> int {
  ::testing::InitGoogleTest(&argc, argv);
  // gtest should remove flags, leaving just input files.
  std::vector<std::string_view> cpp2_files(&argv[1], &argv[argc]);
  cpp2::cpp2_files = &cpp2_files;
  return RUN_ALL_TESTS();
}
